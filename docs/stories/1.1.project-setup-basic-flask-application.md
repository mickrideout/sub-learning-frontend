# Story 1.1: Project Setup and Basic Flask Application

## Status
Ready for Review

## Story
**As a** developer,  
**I want** to establish the basic Flask project structure with essential configurations,  
**so that** I have a solid foundation for building all subsequent features.

## Acceptance Criteria
1. Flask application initialized with proper project structure (`/app`, `/static`, `/templates`, `/migrations`, `/data`)
2. Basic routing configured with health check endpoint returning system status
3. Development environment configuration with environment variables for database and secret keys
4. Version control initialized with appropriate `.gitignore` for Python/Flask projects
5. Requirements.txt file established with core dependencies (Flask, SQLAlchemy, etc.)
6. Basic error handling middleware configured for graceful error responses
7. Application successfully runs locally with `flask run` command

## Tasks / Subtasks
- [x] Initialize Flask Application Factory (AC: 1, 2)
  - [x] Create `app/__init__.py` with Flask app factory pattern
  - [x] Create `app/config.py` for environment-based configuration
  - [x] Create basic health check route in `app/blueprints/main/routes.py`
- [x] Set up Project Structure (AC: 1)
  - [x] Create directory structure according to unified project structure
  - [x] Create `wsgi.py` for WSGI entry point
  - [x] Create `run.py` for development server entry point
- [x] Configure Development Environment (AC: 3)
  - [x] Create `.env.example` with required environment variables template
  - [x] Set up environment variable loading in config
  - [x] Configure Flask development settings
- [x] Initialize Version Control (AC: 4)
  - [x] Create `.gitignore` for Python/Flask projects
  - [x] Initialize git repository if not already done
- [x] Set up Dependencies (AC: 5)
  - [x] Create `requirements.txt` with core Flask dependencies
  - [x] Install Flask, SQLAlchemy, Flask-Migrate, and other core packages
- [x] Configure Error Handling (AC: 6)
  - [x] Create `app/utils/error_handlers.py` for centralized error handling
  - [x] Register error handlers in Flask app factory
  - [x] Create basic error templates
- [x] Test Application Launch (AC: 7)
  - [x] Verify application starts with `flask run`
  - [x] Test health check endpoint
  - [x] Verify proper error responses

## Dev Notes

### Previous Story Insights
This is the first story in the project, so no previous story context applies.

### Tech Stack Requirements
[Source: architecture/tech-stack.md]
- **Backend Framework**: Flask 2.3.x for web application framework
- **Backend Language**: Python 3.9+ for server-side application logic
- **Database**: SQLite 3.x for all data storage (users, subtitles, progress)
- **Authentication**: Flask-Login 0.6.x for user sessions and social login
- **Backend Testing**: pytest 7.x for unit and integration testing
- **Monitoring**: Flask logging (built-in) for application monitoring
- **Logging**: Python logging (built-in) for error tracking and debugging

### Project Structure Requirements
[Source: architecture/unified-project-structure.md]
The project must follow this exact structure:
```
sub-learning/
├── app/                            # Flask application core
│   ├── __init__.py                 # Flask app factory
│   ├── config.py                   # Environment-based configuration
│   ├── blueprints/                 # Flask blueprints organization
│   │   ├── __init__.py
│   │   ├── main/                   # Main application routes
│   │   │   ├── __init__.py
│   │   │   ├── routes.py           # Dashboard, learning interface
│   │   │   └── errors.py           # Error page handlers
│   ├── utils/                      # Shared utilities
│   │   ├── __init__.py
│   │   ├── error_handlers.py       # Centralized error handling
│   ├── static/                     # Frontend assets
│   └── templates/                  # Jinja2 template files
│       ├── base.html               # Base template with navigation
│       └── errors/
│           ├── 404.html            # Not found page
│           ├── 500.html            # Server error page
│           └── offline.html        # Network error fallback
├── instance/                       # Instance-specific files (Pi-local)
├── migrations/                     # Database migration files
├── .env.example                    # Environment variables template
├── .gitignore                      # Git exclusions
├── requirements.txt                # Python dependencies
├── wsgi.py                         # WSGI entry point for production
└── run.py                          # Development server entry point
```

### Coding Standards
[Source: architecture/coding-standards.md]
- **Error Response Consistency**: All API endpoints must return JSON errors with consistent structure: `{"error": "message", "code": "error_type"}` for frontend error handling
- **Flask Blueprints**: Use snake_case naming (e.g., `main_bp`)
- **Environment Variables**: Use UPPER_SNAKE_CASE (e.g., `FLASK_SECRET_KEY`, `DATABASE_URL`)
- **Python Functions**: Use snake_case (e.g., `create_app()`, `register_blueprints()`)

### Required Dependencies
[Source: architecture/tech-stack.md]
Core requirements for requirements.txt:
- Flask==2.3.x
- SQLAlchemy (via Flask-SQLAlchemy)
- Flask-Login==0.6.x
- Flask-Migrate (for future database setup)
- python-dotenv (for environment variable loading)

### Environment Configuration Requirements
[Source: architecture/development-workflow.md]
Required environment variables template:
- `FLASK_SECRET_KEY`: For session security
- `DATABASE_URL`: SQLite database connection
- `FLASK_ENV`: development/production
- `FLASK_DEBUG`: true/false for debug mode

### Error Handling Requirements
[Source: architecture/coding-standards.md]
- Centralized error handling in `app/utils/error_handlers.py`
- Consistent JSON error format for API responses
- Custom error templates for 404, 500, and offline scenarios
- Graceful error responses to prevent system crashes on Pi

### File Locations for New Code
[Source: architecture/unified-project-structure.md]
- Flask app factory: `app/__init__.py`
- Configuration: `app/config.py`
- Main routes: `app/blueprints/main/routes.py`
- Error handlers: `app/utils/error_handlers.py`
- Error templates: `app/templates/errors/`
- WSGI entry: `wsgi.py` (project root)
- Development server: `run.py` (project root)

### Testing Requirements
[Source: architecture/testing-strategy.md]
- Use pytest 7.x for backend testing
- Test files location: `tests/` directory
- Configuration file: `tests/conftest.py`
- Include unit tests for Flask app factory and basic routing
- Test error handling functionality

### Technical Constraints
[Source: architecture/tech-stack.md]
- Pi resource optimization: Lightweight components only
- No build tools or bundlers: Direct file serving
- Local filesystem storage: No cloud dependencies
- SQLite for all data storage: Single-file database

## Testing

### Testing Standards
[Source: architecture/testing-strategy.md]
- **Test File Location**: All tests in `tests/` directory
- **Test Framework**: pytest 7.x for backend unit and integration testing
- **Test Configuration**: Use `tests/conftest.py` for pytest configuration and fixtures
- **Test Organization**: Organize tests by component type (models, services, api, integration)
- **Testing Patterns**: 
  - Unit tests for individual functions and components
  - Integration tests for Flask application startup and routing
  - Test error handling scenarios
- **Specific Requirements for This Story**:
  - Test Flask app factory initialization
  - Test health check endpoint functionality
  - Test error handler registration and responses
  - Test configuration loading from environment variables

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-18 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
Claude Sonnet 4 (claude-sonnet-4-20250514)

### Debug Log References
No debug logs required - implementation completed successfully on first attempt.

### Completion Notes List
- Flask application factory pattern implemented with proper configuration management
- Project structure follows unified architecture specifications exactly
- All core dependencies installed and verified working
- Comprehensive error handling with JSON/HTML response differentiation
- Health check endpoint provides system status information
- All tests passing (6/6) with comprehensive coverage
- Application successfully starts and serves requests

### File List
**New Files Created:**
- `app/__init__.py` - Flask application factory
- `app/config.py` - Environment-based configuration
- `app/blueprints/__init__.py` - Blueprints package
- `app/blueprints/main/__init__.py` - Main blueprint initialization
- `app/blueprints/main/routes.py` - Main routes with health check
- `app/utils/__init__.py` - Utils package
- `app/utils/error_handlers.py` - Centralized error handling
- `app/templates/base.html` - Base HTML template
- `app/templates/errors/404.html` - 404 error template
- `app/templates/errors/500.html` - 500 error template
- `app/templates/errors/offline.html` - Offline error template
- `wsgi.py` - WSGI entry point
- `run.py` - Development server entry point
- `.env.example` - Environment variables template
- `requirements.txt` - Python dependencies
- `tests/__init__.py` - Test package
- `tests/conftest.py` - Pytest configuration
- `tests/test_app_factory.py` - App factory tests
- `tests/test_routes.py` - Route tests
- `tests/test_error_handlers.py` - Error handler tests

**Directories Created:**
- `app/` - Main application directory
- `app/blueprints/main/` - Main blueprint
- `app/utils/` - Utilities
- `app/static/` - Static assets (empty)
- `app/templates/errors/` - Error templates
- `instance/` - Instance-specific files
- `migrations/` - Database migrations (empty)
- `tests/` - Test directory

## QA Results
*Results from QA Agent review will be populated here*